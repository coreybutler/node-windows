{
  "name": "seq",
  "version": "0.3.5",
  "description": "Chainable asynchronous flow control with sequential and parallel primitives and pipeline-style error handling",
  "main": "./index.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/substack/node-seq.git"
  },
  "dependencies": {
    "chainsaw": ">=0.0.7 <0.1",
    "hashish": ">=0.0.2 <0.1"
  },
  "devDependencies": {
    "expresso": ">=0.7.x"
  },
  "script": {
    "test": "expresso"
  },
  "keywords": [
    "flow-control",
    "flow",
    "control",
    "async",
    "asynchronous",
    "chain",
    "pipeline",
    "sequence",
    "sequential",
    "parallel",
    "error"
  ],
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "license": "MIT/X11",
  "engine": {
    "node": ">=0.4.0"
  },
  "readme": "Seq\n===\n\nSeq is an asynchronous flow control library with a chainable interface for\nsequential and parallel actions. Even the error handling is chainable.\n\nEach action in the chain operates on a stack of values.\nThere is also a variables hash for storing values by name.\n\n[TOC]\n\n\n\nExamples\n========\n\nstat_all.js\n-----------\n\n````javascript\nvar fs = require('fs');\nvar Hash = require('hashish');\nvar Seq = require('seq');\n\nSeq()\n    .seq(function () {\n        fs.readdir(__dirname, this);\n    })\n    .flatten()\n    .parEach(function (file) {\n        fs.stat(__dirname + '/' + file, this.into(file));\n    })\n    .seq(function () {\n        var sizes = Hash.map(this.vars, function (s) { return s.size })\n        console.dir(sizes);\n    })\n;\n````\n\nOutput:\n\n    { 'stat_all.js': 404, 'parseq.js': 464 }\n\nparseq.js\n---------\n\n````javascript\nvar fs = require('fs');\nvar exec = require('child_process').exec;\n\nvar Seq = require('seq');\nSeq()\n    .seq(function () {\n        exec('whoami', this)\n    })\n    .par(function (who) {\n        exec('groups ' + who, this);\n    })\n    .par(function (who) {\n        fs.readFile(__filename, 'ascii', this);\n    })\n    .seq(function (groups, src) {\n        console.log('Groups: ' + groups.trim());\n        console.log('This file has ' + src.length + ' bytes');\n    })\n;\n````\n\nOutput:\n\n    Groups: substack : substack dialout cdrom floppy audio src video plugdev games netdev fuse www\n    This file has 464 bytes\n\n\n\n\nAPI\n===\n\nEach method executes callbacks with a context (its `this`) described in the next\nsection. Every method returns `this`.\n\nWhenever `this()` is called with a non-falsy first argument, the error value\npropagates down to the first `catch` it sees, skipping over all actions in\nbetween. There is an implicit `catch` at the end of all chains that prints the\nerror stack if available and otherwise just prints the error.\n\n\n\nSeq(xs=[])\n----------\n\nThe constructor function creates a new `Seq` chain with the methods described\nbelow. The optional array argument becomes the new context stack.\n\nArray argument is new in 0.3. `Seq()` now behaves like `Seq.ap()`.\n\n\n.seq(cb)\n--------\n.seq(key, cb, *args)\n--------------------\n\nThis eponymous function executes actions sequentially.\nOnce all running parallel actions are finished executing,\nthe supplied callback is `apply()`'d with the context stack.\n\nTo execute the next action in the chain, call `this()`. The first\nargument must be the error value. The rest of the values will become the stack\nfor the next action in the chain and are also available at `this.args`.\n\nIf `key` is specified, the second argument sent to `this` goes to\n`this.vars[key]` in addition to the stack and `this.args`.\n`this.vars` persists across all requests unless it is overwritten.\n\nAll arguments after `cb` will be bound to `cb`, which is useful because\n`.bind()` makes you set `this`. If you pass in `Seq` in the arguments list,\nit'll get transformed into `this` so that you can do:\n\n````javascript\nSeq()\n    .seq(fs.readdir, __dirname, Seq)\n    .seq(function (files) { console.dir(files) })\n;\n````\n\nwhich prints an array of files in `__dirname`.\n\n\n.par(cb)\n--------\n.par(key, cb, *args)\n--------------------\n\nUse `par` to execute actions in parallel.\nChain multiple parallel actions together and collect all the responses on the\nstack with a sequential operation like `seq`.\n\nEach `par` sets one element in the stack with the second argument to `this()` in\nthe order in which it appears, so multiple `par`s can be chained together.\n\nLike with `seq`, the first argument to `this()` should be the error value and\nthe second will get pushed to the stack. Further arguments are available in\n`this.args`.\n\nIf `key` is specified, the result from the second argument send to `this()` goes\nto `this.vars[key]`.\n`this.vars` persists across all requests unless it is overwritten.\n\nAll arguments after `cb` will be bound to `cb`, which is useful because\n`.bind()` makes you set `this`. Like `.seq()`, you can pass along `Seq` in these\nbound arguments and it will get tranformed into `this`.\n\n\n.catch(cb)\n----------\n\nCatch errors. Whenever a function calls `this` with a non-falsy first argument,\nthe message propagates down the chain to the first `catch` it sees.\nThe callback `cb` fires with the error object as its first argument and the key\nthat the action that caused the error was populating, which may be undefined.\n\n`catch` is a sequential action and further actions may appear after a `catch` in\na chain. If the execution reaches a `catch` in a chain and no error has occured,\nthe `catch` is skipped over.\n\nFor convenience, there is a default error handler at the end of all chains.\nThis default error handler looks like this:\n\n````javascript\n.catch(function (err) {\n    console.error(err.stack ? err.stack : err)\n})\n````\n\n\n.forEach(cb)\n------------\n\nExecute each action in the stack under the context of the chain object.\n`forEach` does not wait for any of the actions to finish and does not itself\nalter the stack, but the callback may alter the stack itself by modifying\n`this.stack`.\n\nThe callback is executed `cb(x,i)` where `x` is the element and `i` is the\nindex. \n\n`forEach` is a sequential operation like `seq` and won't run until all pending\nparallel requests yield results.\n\n\n.seqEach(cb)\n------------\n\nLike `forEach`, call `cb` for each element on the stack, but unlike `forEach`,\n`seqEach` waits for the callback to yield with `this` before moving on to the\nnext element in the stack.\n\nThe callback is executed `cb(x,i)` where `x` is the element and `i` is the\nindex. \n\nIf `this()` is supplied non-falsy error, the error propagates downward but any\nother arguments are ignored. `seqEach` does not modify the stack itself.\n\n\n.parEach(cb)\n------------\n.parEach(limit, cb)\n-------------------\n\nLike `forEach`, calls cb for each element in the stack and doesn't wait for the\ncallback to yield a result with `this()` before moving on to the next iteration.\nUnlike `forEach`, `parEach` waits for all actions to call `this()` before moving\nalong to the next action in the chain.\n\nThe callback is executed `cb(x,i)` where `x` is the element and `i` is the\nindex. \n\n`parEach` does not modify the stack itself and errors supplied to `this()`\npropagate.\n\nOptionally, if limit is supplied to `parEach`, at most `limit` callbacks will be\nactive at a time.\n\n\n.seqMap(cb)\n-----------\n\nLike `seqEach`, but collect the values supplied to `this` and set the stack to\nthese values.\n\n\n.parMap(cb)\n-----------\n.parMap(limit, cb)\n------------------\n\nLike `parEach`, but collect the values supplied to `this` and set the stack to\nthese values.\n\n\n.seqFilter(cb)\n-----------\n\nExecutes the callback `cb(x, idx)` against each element on the stack, waiting for the\ncallback to yield with `this` before moving on to the next element. If the callback \nreturns an error or a falsey value, the element will not be included in the resulting\nstack.\n\nAny errors from the callback are consumed and **do not** propagate.\n\nCalls to `this.into(i)` will place the value, if accepted by the callback, at the index in\nthe results as if it were ordered at i-th index on the stack before filtering (with ties\nbroken by the values). This implies `this.into` will never override another stack value\neven if their indices collide. Finally, the value will only actually appear at `i` if the\ncallback accepts or moves enough values before `i`.\n\n\n.parFilter(cb)\n-----------\n.parFilter(limit, cb)\n------------------\n\nExecutes the callback `cb(x, idx)` against each element on the stack, but **does not**\nwait for it to yield before moving on to the next element. If the callback returns an\nerror or a falsey value, the element will not be included in the resulting stack.\n\nAny errors from the callback are consumed and **do not** propagate.\n\nCalls to `this.into(i)` will place the value, if accepted by the callback, at the index in\nthe results as if it were ordered at i-th index on the stack before filtering (with ties\nbroken by the values). This implies `this.into` will never override another stack value\neven if their indices collide. Finally, the value will only actually appear at `i` if the\ncallback accepts or moves enough values before `i`.\n\nOptionally, if limit is supplied to `parEach`, at most `limit` callbacks will be\nactive at a time.\n\n\n.do(cb)\n-------\nCreate a new nested context. `cb`'s first argument is the previous context, and `this`\nis the nested `Seq` object.\n\n\n.flatten(fully=true)\n--------------------\n\nRecursively flatten all the arrays in the stack. Set `fully=false` to flatten\nonly one level.\n\n\n.unflatten()\n------------\n\nTurn the contents of the stack into a single array item. You can think of it\nas the inverse of `flatten(false)`.\n\n\n.extend([x,y...])\n-----------------\n\nLike `push`, but takes an array. This is like python's `[].extend()`.\n\n\n.set(xs)\n--------\n\nSet the stack to a new array. This assigns the reference, it does not copy.\n\n\n.empty()\n--------\n\nSet the stack to [].\n\n\n.push(x,y...), .pop(), .shift(), .unshift(x), .splice(...), reverse()\n---------------------------------------------------------------------\n.map(...), .filter(...), .reduce(...)\n-------------------------------------\n\nExecutes an array operation on the stack.\n\nThe methods `map`, `filter`, and `reduce` are also proxies to their Array counterparts:\nthey have identical signatures to the Array methods, operate synchronously on the context\nstack, and do not pass a Context object (unlike `seqMap` and `parMap`).\n\nThe result of the transformation is assigned to the context stack; in the case of `reduce`,\nif you do not return an array, the value will be wrapped in one.\n\n````javascript\nSeq([1, 2, 3])\n    .reduce(function(sum, x){ return sum + x; }, 0)\n    .seq(function(sum){\n        console.log('sum: %s', sum);\n        // sum: 6\n        console.log('stack is Array?', Array.isArray(this.stack));\n        // stack is Array: true\n        console.log('stack:', this.stack);\n        // stack: [6]\n    })\n;\n````\n\n\n\n\nExplicit Parameters\n-------------------\n\nFor environments like coffee-script or nested logic where threading `this` is\nbothersome, you can use:\n\n* seq_\n* par_\n* forEach_\n* seqEach_\n* parEach_\n* seqMap_\n* parMap_\n\nwhich work exactly like their un-underscored counterparts except for the first\nparameter to the supplied callback is set to the context, `this`.\n\n\n\nContext Object\n==============\n\nEach callback gets executed with its `this` set to a function in order to yield\nresults, error values, and control. The function also has these useful fields:\n\nthis.stack\n----------\n\nThe execution stack.\n\nthis.stack_\n-----------\n\nThe previous stack value, mostly used internally for hackish purposes.\n\nthis.vars\n---------\n\nA hash of key/values populated with `par(key, ...)`, `seq(key, ...)` and\n`this.into(key)`.\n\nthis.into(key)\n--------------\n\nInstead of sending values to the stack, sets a key and returns `this`.\nUse `this.into(key)` interchangeably with `this` for yielding keyed results.\n`into` overrides the optional key set by `par(key, ...)` and `seq(key, ...)`.\n\nthis.ok\n-------\n\nSet the `err` to null. Equivalent to `this.bind(this, null)`.\n\nthis.args\n---------\n\n`this.args` is like `this.stack`, but it contains all the arguments to `this()`\npast the error value, not just the first. `this.args` is an array with the same\nindices as `this.stack` but also stores keyed values for the last sequential\noperation. Each element in `this.array` is set to `[].slice.call(arguments, 1)`\nfrom inside `this()`.\n\nthis.error\n----------\n\nThis is used for error propagation. You probably shouldn't mess with it.\n\n\n\nInstallation\n============\n\nWith [npm](http://github.com/isaacs/npm), just do:\n\n    npm install seq\n\nor clone this project on github:\n\n    git clone http://github.com/substack/node-seq.git\n\nTo run the tests with [expresso](http://github.com/visionmedia/expresso),\njust do:\n\n    expresso\n\n\n\nDependencies\n------------\n\nThis module uses [chainsaw](http://github.com/substack/node-chainsaw)\nWhen you `npm install seq` this dependency will automatically be installed.\n\n\n",
  "readmeFilename": "README.markdown",
  "_id": "seq@0.3.5",
  "_from": "seq@~0.3.5"
}
